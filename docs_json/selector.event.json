[{"ignore": false, "code": "// Keep in memory the events created\ntiramisu.modules.local_event = {};\ntiramisu.modules.get.methods.event = {\n\n    // Each module within Tiramisu can to need inherit other modules.\n    // The number of cups of coffee is identified for each module.\n    'ingredients': [1],\n    'cups_of_coffee': 5,\n\n    'on': function(evt, cb) {\n        if (arguments.length > 2) {\n            return '';\n        }\n        var evt_len = 1,\n            ev = [],\n            callback = [];\n        if (typeof(evt) === 'string') {\n            ev[0] = evt;\n            callback[0] = cb;\n        } else if (typeof(evt) === 'object') {\n            if (typeof(evt[0]) === 'string') {\n                ev = evt;\n                callback[0] = cb;\n            } else {\n                for (key in evt) {\n                    evt_len = ev.push(key);\n                    callback.push(evt[key]);\n                }\n            }\n        }\n        // if this[0] === undefined : *SELECTOR* is not a valid CSS selector or not exist;\n        for (var j = evt_len; j--;) {\n            var cb = callback[j];\n            for (i = this.length; i--;) {\n                add_handler(this[i], ev[j], cb);\n            }\n            if (typeof selector === 'string') {\n                t.local_event[selector] = {};\n                t.local_event[selector] = {\n                    'cb': cb,\n                    'element': this\n                };\n            }\n        }\n        return this;\n    },\n\n    'off': function(evt) {\n        if (arguments.length > 1) {\n            return '';\n        }\n        if (typeof selector === 'string') {\n            if (t.local_event[selector] !== undefined) {\n                var cb = t.local_event[selector]['cb'],\n                    element = t.local_event[selector]['element'],\n                    len = element.length;\n                for (i = len; i--;) {\n                    remove_handler(tiramisu.get.results[i], evt, cb);\n                }\n                delete t.local_event[selector];\n            }\n        }\n\n        return this;\n    },\n}\n\n// The good way to eliminate a work repetition in functions is through lazy loading.\n// Lazy loading means that no work is done until the information is necessary.\n// Here I implement a lazy-loading pattern. The first time either method is\n// called, a check is made to determine the appropriate way to attach or detach the\n// event handler. Then the original function is overwrittern with a new function that\n// contains just the appropriate course of action.\n// By High Performance JavaScript, Nicholas C. Zakas\nvar add_handler = function(target, event_type, handler) {\n\n        // overwrite te existing function\n        if (target.addEventListener) { // DOM 2 Events\n            add_handler = function(target, event_type, handler) {\n                target.addEventListener(event_type, handler, false);\n            }\n        } else { // IE\n            add_handler = function(target, event_type, handler) {\n                target.attachEvent('on' + event_type, wrap_handler(handler));\n            }\n        }\n\n        // call the new functions\n        add_handler(target, event_type, handler);\n    }\n\n    // And brother function, remove_handler\nvar remove_handler = function(target, event_type, handler) {\n\n        // overwrite te existing function\n        if (target.removeEventListener) { // DOM 2 Events\n            remove_handler = function(target, event_type, handler) {\n                target.removeEventListener(event_type, handler, false);\n            }\n        } else { // IE\n            remove_handler = function(target, event_type, handler) {\n                target.detachEvent('on' + event_type, wrap_handler(handler));\n            }\n        }\n\n        // call the new functions\n        remove_handler(target, event_type, handler);\n    }\n\nfunction wrap_handler(target, handler) {\n    return function(e) {\n        // get event and source element\n        e = e || window.event;\n\n        if (e) {\n            // prevent default action\n            if (!e.preventDefault) {\n                e.preventDefault = function() {\n                    e.returnValue = false;\n                }\n            }\n\n            // no bubble\n            if (!e.stopPropagation) {\n                e.stopPropagation = function() {\n                    e.cancelBubble = true;\n                }\n            }\n        }\n\n        handler.call(target, e);\n    };\n}", "description": {"body": "<h2>Several methods for Events tasks</h2>\n\n<ul>\n<li>*On/Off</li>\n</ul>\n\n<h2>Event handler extension</h2>\n\n<p>Attach a callback function to an event.</p>\n\n<pre><code>tiramisu.get(*SELECTOR*).on(*EVENT*, *CALLBACK*)\n</code></pre>\n\n<p>where <em>SELECTOR</em> is a valid CSS selector, <em>EVENT</em> is the event listener and <em>CALLBACK</em><br />the function to attach.</p>\n\n<p>Example #1 (Clicking on a p element displays \u201cHello!\u201d)</p>\n\n<pre><code>&lt;p&gt; Click me! &lt;/p&gt;\n&lt;p&gt; Click me too! &lt;/p&gt;\n&lt;p&gt; And me? &lt;/p&gt;\n...\ntiramisu.get('p').on('click', function() {\n    alert('Hello!');\n});\n</code></pre>\n\n<p>Example #2 (Hovering on a li element displays his innerHTML)</p>\n\n<pre><code> &lt;ol&gt;\n   &lt;li&gt; Banana &lt;/li&gt;\n   &lt;li&gt; Apple &lt;/li&gt;\n   &lt;li&gt; Pineapple &lt;/li&gt;\n   &lt;li&gt; Strawberry &lt;/li&gt;\n &lt;/ol&gt;\n ...\n tiramisu.get('ul li').on('mouseover', function() {\n     alert(this.innerHTML);\n });\n</code></pre>\n\n<p>As in the \u201ceach\u201d example, it is possible to use <strong>this</strong> to reference the current list item.</p>\n\n<p>Example #3 (Defining a window.onload callback)</p>\n\n<pre><code>tiramisu.get(window).on('load', function() {\n    alert('This will be executed after the DOM loading\");\n});\n</code></pre>\n\n<p>Example #4 (Alert message when pressing the \u201cm\u201d key)</p>\n\n<pre><code>tiramisu.get(document).on('keydown', function(evt) {\n    if (evt.keyCode == 77) {\n        alert(\"M as Marvelous!\");\n    }\n});\n</code></pre>\n\n<p>Example #5 ()</p>\n\n<pre><code>tiramisu.get('p').on('keydown', 'click', function(evt) {\n    alert('This will be executed after click or keydown on 'p' element\");\n});\n</code></pre>\n\n<p>param {event} evt An event listener<br />param {function} cb The callback function to attach</p>\n\n<h1>Remove Event handler extension</h1>\n\n<p>need documentation</p>", "full": "<h1>Event Selector methods</h1>\n\n<h2>Several methods for Events tasks</h2>\n\n<ul>\n<li>*On/Off</li>\n</ul>\n\n<h2>Event handler extension</h2>\n\n<p>Attach a callback function to an event.</p>\n\n<pre><code>tiramisu.get(*SELECTOR*).on(*EVENT*, *CALLBACK*)\n</code></pre>\n\n<p>where <em>SELECTOR</em> is a valid CSS selector, <em>EVENT</em> is the event listener and <em>CALLBACK</em><br />the function to attach.</p>\n\n<p>Example #1 (Clicking on a p element displays \u201cHello!\u201d)</p>\n\n<pre><code>&lt;p&gt; Click me! &lt;/p&gt;\n&lt;p&gt; Click me too! &lt;/p&gt;\n&lt;p&gt; And me? &lt;/p&gt;\n...\ntiramisu.get('p').on('click', function() {\n    alert('Hello!');\n});\n</code></pre>\n\n<p>Example #2 (Hovering on a li element displays his innerHTML)</p>\n\n<pre><code> &lt;ol&gt;\n   &lt;li&gt; Banana &lt;/li&gt;\n   &lt;li&gt; Apple &lt;/li&gt;\n   &lt;li&gt; Pineapple &lt;/li&gt;\n   &lt;li&gt; Strawberry &lt;/li&gt;\n &lt;/ol&gt;\n ...\n tiramisu.get('ul li').on('mouseover', function() {\n     alert(this.innerHTML);\n });\n</code></pre>\n\n<p>As in the \u201ceach\u201d example, it is possible to use <strong>this</strong> to reference the current list item.</p>\n\n<p>Example #3 (Defining a window.onload callback)</p>\n\n<pre><code>tiramisu.get(window).on('load', function() {\n    alert('This will be executed after the DOM loading\");\n});\n</code></pre>\n\n<p>Example #4 (Alert message when pressing the \u201cm\u201d key)</p>\n\n<pre><code>tiramisu.get(document).on('keydown', function(evt) {\n    if (evt.keyCode == 77) {\n        alert(\"M as Marvelous!\");\n    }\n});\n</code></pre>\n\n<p>Example #5 ()</p>\n\n<pre><code>tiramisu.get('p').on('keydown', 'click', function(evt) {\n    alert('This will be executed after click or keydown on 'p' element\");\n});\n</code></pre>\n\n<p>param {event} evt An event listener<br />param {function} cb The callback function to attach</p>\n\n<h1>Remove Event handler extension</h1>\n\n<p>need documentation</p>", "summary": "<h1>Event Selector methods</h1>"}, "tags": []}]